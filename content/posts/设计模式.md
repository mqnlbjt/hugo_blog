---
title: "设计模式"
date: 2025-08-10T23:01:27+08:00
draft: false
tags: []
---

## 工厂方法模式

+ 需要根据不同的配置或参数，连接不同类型的数据库（MySQL, PostgreSQL, MongoDB）。
+ 需要根据用户的选择，使用不同的支付渠道（支付宝, 微信支付）。
+ 需要将日志记录到不同的目的地（文件, 控制台, 远程服务器）。

在种情况下，业务逻辑是稳定的，比如连接数据库,支付这些都是固定的，但是下游完成这些的对象是不同的，如果不使用任何抽象，就需要很多的if-else设置不同的对象处理，时间一长代码的可维护性就下降了。

**工厂模式又称工厂方法模式，是一种创建型设计模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。**

定义一个创建对象的接口，由子类决定实例化哪个，将对象的创建延迟到子类，屏蔽每一个功能类中的实现逻辑，外部只需要调用，可能存在子类过多管理困难的后果。

### 案例

奖励的分发：给予用户一共三种奖励

| 序号 | 类型         |                             接口                             |
| ---- | ------------ | :----------------------------------------------------------: |
| 1    | 优惠券       | `CouponResult sendCoupon(String uId, String couponNumber, String uuid)` |
| 2    | 实物商品     |            `Boolean deliverGoods(DeliverReq req)`            |
| 3    | 第三方兑换卡 |  `void grantToken(String bindMobileNumber, String cardId)`   |

三个接口的出入参是不同的：

1. 优惠劵需要**用户id** **优惠劵编号** **操作id(防止重复)**
2. 实物需要多出一个收货信息
3. 兑换卡需要手机号和兑换卡的id

```java
/*if-else版本*/
public class PrizeController {
     public AwardRes awardToUser(AwardReq req) {
         try{
               if（req.getAwardType() == 1）{
             //优惠劵发放逻辑
         }else if（req.getAwardType() == 2）{
             //实物发放逻辑
         }else if(req.getAwardType() == 3){
             //兑换卡逻辑
         }
       }catch(Exception e){
            //失败逻辑
         }
         return res；
     }
}
```

当奖励种类更多的时候只能添加更多的分支，测试回归的时间也会更长。

如果定义一个父接口，接口的入参包括`用户ID`、`奖品ID`、`业务ID`以及`扩展字段`用于处理发放实物商品时的收获地址。

``` java
public interface ICommodity {

    void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception;

}



/*优惠劵实现类*/
public class CouponCommodityService implements ICommodity {
       private CouponService couponService = new CouponService();
    public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
        //逻辑
    }
}


/*实物实现类*/
public class GoodsCommodityService implements ICommodity {
     private GoodsService goodsService = new GoodsService();
      public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
          //逻辑
      }
}


/*兑换卡实现类*/
public class GoodsCommodityService implements ICommodity {
      private IQiYiCardService iQiYiCardService = new IQiYiCardService();
      public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
          //逻辑
      }
}
```

任何一种奖品的发放都不影响其它奖品，在统一了入参以及出参后，调用方不再需要关心奖品发放的内部逻辑，按照统一的方式即可处理。

```java
public class StoreFactory {

    public ICommodity getCommodityService(Integer commodityType) {
        if (null == commodityType) return null;
        if (1 == commodityType) return new CouponCommodityService();
        if (2 == commodityType) return new GoodsCommodityService();
        if (3 == commodityType) return new CardCommodityService();
        throw new RuntimeException("不存在的商品服务类型");
    }

}

```



在调用时需要传入type，自动获取对应的service

``` java 
public class PrizeController(){
    public void commodity(PrizeReq req){
        StoreFactory storeFactory = new StoreFactory();
            ICommodity commodityService = storeFactory.getCommodityService(req.getType);
    }
}
```

它的优点；`避免创建者与具体的产品逻辑耦合`、`满足单一职责，每一个业务逻辑实现都在所属自己的类中完成`、`满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型`。但这样也会带来一些问题，比如有非常多的奖品类型，那么实现的子类会极速扩张。

