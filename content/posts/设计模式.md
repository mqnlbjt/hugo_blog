---
title: "设计模式"
date: 2025-08-10T23:01:27+08:00
draft: false
tags: []
---

## 工厂方法模式

+ 需要根据不同的配置或参数，连接不同类型的数据库（MySQL, PostgreSQL, MongoDB）。
+ 需要根据用户的选择，使用不同的支付渠道（支付宝, 微信支付）。
+ 需要将日志记录到不同的目的地（文件, 控制台, 远程服务器）。

在种情况下，业务逻辑是稳定的，比如连接数据库,支付这些都是固定的，但是下游完成这些的对象是不同的，如果不使用任何抽象，就需要很多的if-else设置不同的对象处理，时间一长代码的可维护性就下降了。

**工厂模式又称工厂方法模式，是一种创建型设计模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。**

定义一个创建对象的接口，由子类决定实例化哪个，将对象的创建延迟到子类，屏蔽每一个功能类中的实现逻辑，外部只需要调用，可能存在子类过多管理困难的后果。

### 案例

奖励的分发：给予用户一共三种奖励

| 序号 | 类型         |                             接口                             |
| ---- | ------------ | :----------------------------------------------------------: |
| 1    | 优惠券       | `CouponResult sendCoupon(String uId, String couponNumber, String uuid)` |
| 2    | 实物商品     |            `Boolean deliverGoods(DeliverReq req)`            |
| 3    | 第三方兑换卡 |  `void grantToken(String bindMobileNumber, String cardId)`   |

三个接口的出入参是不同的：

1. 优惠劵需要**用户id** **优惠劵编号** **操作id(防止重复)**
2. 实物需要多出一个收货信息
3. 兑换卡需要手机号和兑换卡的id

```java
/*if-else版本*/
public class PrizeController {
     public AwardRes awardToUser(AwardReq req) {
         try{
               if（req.getAwardType() == 1）{
             //优惠劵发放逻辑
         }else if（req.getAwardType() == 2）{
             //实物发放逻辑
         }else if(req.getAwardType() == 3){
             //兑换卡逻辑
         }
       }catch(Exception e){
            //失败逻辑
         }
         return res；
     }
}
```

当奖励种类更多的时候只能添加更多的分支，测试回归的时间也会更长。

如果定义一个父接口，接口的入参包括`用户ID`、`奖品ID`、`业务ID`以及`扩展字段`用于处理发放实物商品时的收获地址。

``` java
public interface ICommodity {

    void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception;

}



/*优惠劵实现类*/
public class CouponCommodityService implements ICommodity {
       private CouponService couponService = new CouponService();
    public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
        //逻辑
    }
}


/*实物实现类*/
public class GoodsCommodityService implements ICommodity {
     private GoodsService goodsService = new GoodsService();
      public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
          //逻辑
      }
}


/*兑换卡实现类*/
public class CardCommodityService implements ICommodity {
      private CardService iQiYiCardService = new CardService();
      public void sendCommodity(String uId, String commodityId, String bizId, Map<String, String> extMap) throws Exception {
          //逻辑
      }
}
```

任何一种奖品的发放都不影响其它奖品，在统一了入参以及出参后，调用方不再需要关心奖品发放的内部逻辑，按照统一的方式即可处理。

```java
public class StoreFactory {

    public ICommodity getCommodityService(Integer commodityType) {
        if (null == commodityType) return null;
        if (1 == commodityType) return new CouponCommodityService();
        if (2 == commodityType) return new GoodsCommodityService();
        if (3 == commodityType) return new CardCommodityService();
        throw new RuntimeException("不存在的商品服务类型");
    }

}

```



在调用时需要传入type，自动获取对应的service

``` java 
public class PrizeController(){
    public void commodity(PrizeReq req){
        StoreFactory storeFactory = new StoreFactory();
            ICommodity commodityService = storeFactory.getCommodityService(req.getType);
    }
}
```

它的优点；`避免创建者与具体的产品逻辑耦合`、`满足单一职责，每一个业务逻辑实现都在所属自己的类中完成`、`满足开闭原则，无需更改使用调用方就可以在程序中引入新的产品类型`。但这样也会带来一些问题，比如有非常多的奖品类型，那么实现的子类会极速扩张。

## 抽象工厂模式

抽象工厂模式与工厂方法模式虽然主要意图都是为了解决，**接口选择**问题。但在实现上，抽象工厂是一个中心工厂，创建其他工厂的模式。

抽象工厂是其他工厂的工厂听上去很抽象，如果有很复杂的系统，一个大的服务需要多个小服务的支持，相当于对原先的工厂方法模式再多了一层抽象。

### 案例

现在有一个老项目要升级，需要对接三个redis服务

+ 自建redis单机
+ redis 集群A
+ redis 集群B

>  兼容这三套redis就会出现一些问题
>
> 1. 需要兼容集群A和集群B，便于后续的灾备。
> 2. 两套集群提供的接口和方法各有差异，需要做适配。
> 3. 不能影响到目前正常运行的系统。

```java
/*模拟redis单机*/
public class RedisUtils{
    public String get(){
        ...
    }
     public void set(){
        ...
    }
     public void set(){
        ...
    }
     public void del(){
        ...
    }
}
```

这部分代码被很多服务调用，方法名被写死在业务系统中。



``` java
/*集群A*/
public class RedisClusterA{
    public String gain(){ ... }
    public void set(){ ...  }
    public void setEx(){ ...  }
    public void delete(){ ...  }
}

/*集群B*/
public class RedisClusterB{
    public String getInfo(){ ... }
    public void set(){ ...  }
    public void setExpire(){ ...  }
    public void delete(){ ...  }
}

```

系统中已经在大量的使用redis服务，但是因为系统不能满足业务的快速发展，因此需要迁移到集群服务中。而这时有两套集群服务需要兼容使用，又要满足所有的业务系统改造的同时不影响线上使用。

使用工厂方法模式获得的代码如下

``` java
public interface CacheService {

    String get(final String key);

    void set(String key, String value);

    void set(String key, String value, long timeout, TimeUnit timeUnit);

    void del(String key);

}

public class SingleCacheServiceImpl implements CacheService {
    private RedisUtils redisUtils = new RedisUtils();
    /*逻辑实现*/
}

public class RedisClusterACacheServiceImpl implements CacheService {
    private RedisClusterA redisClusterA = new RedisClusterA();
    /*逻辑实现*/
}

public class RedisClusterBCacheServiceImpl implements CacheService {
    private RedisClusterB redisClusterB = new RedisClusterB();
    /*逻辑实现*/
}

public interface ICacheServiceFactory {
    CacheService createCacheService();
}

public class SingleCacheServiceFactory implements ICacheServiceFactory 
{
    //创建 SingleCacheServiceImpl
}

public class RedisClusterACacheServiceFactory implements ICacheServiceFactory 
{
    //创建 RedisClusterACacheServiceImpl
}
public class RedisClusterBCacheServiceFactory implements ICacheServiceFactory 
{
   // 创建 RedisClusterBCacheServiceImpl
}


public class Client {

    public static void main(String[] args) {
        // 场景1: 我需要一个单机版的缓存服务
        ICacheServiceFactory singleFactory = new SingleCacheServiceFactory();
        CacheService singleCacheService = singleFactory.createCacheService();
        singleCacheService.set("user:1", "data_from_single");
        System.out.println("从单机缓存中获取: " + singleCacheService.get("user:1"));


        // 场景2: 我需要一个A集群的缓存服务
        ICacheServiceFactory clusterAFactory = new RedisClusterACacheServiceFactory();
        CacheService clusterACacheService = clusterAFactory.createCacheService();
        clusterACacheService.set("user:2", "data_from_cluster_A");
        System.out.println("从A集群缓存中获取: " + clusterACacheService.get("user:2"));
        

        // 场景3: 我需要一个B集群的缓存服务
        ICacheServiceFactory clusterBFactory = new RedisClusterBCacheServiceFactory();
        CacheService clusterBCacheService = clusterBFactory.createCacheService();
        clusterBCacheService.set("user:3", "data_from_cluster_B");
        System.out.println("从B集群缓存中获取: " + clusterBCacheService.get("user:3"));
    }
}

```

接下来使用抽象工厂模式：

```java
public interface ICacheAdapter {

    String get(String key);

    void set(String key, String value);

    void set(String key, String value, long timeout, TimeUnit timeUnit);

    void del(String key);

}



public class RedisClusterACacheAdapter implements ICacheAdapter {
    //实现RedisClusterA逻辑
}

public class RedisClusterBCacheAdapter implements ICacheAdapter {
    //实现RedisClusterB逻辑
}


public static <T> T getProxy(Class<T> interfaceClass, ICacheAdapter cacheAdapter) throws Exception {
    InvocationHandler handler = new JDKInvocationHandler(cacheAdapter);
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    Class<?>[] classes = interfaceClass.getInterfaces();
    return (T) Proxy.newProxyInstance(classLoader, new Class[]{classes[0]}, handler);
}


public class JDKInvocationHandler implements InvocationHandler {

    private ICacheAdapter cacheAdapter;

    public JDKInvocationHandler(ICacheAdapter cacheAdapter) {
        this.cacheAdapter = cacheAdapter;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return ICacheAdapter.class.getMethod(method.getName(), ClassLoaderUtils.getClazzByArgs(args)).invoke(cacheAdapter, args);
    }

}

```



## 三种工厂模式对比

| 特性         | 简单工厂模式                 | 工厂方法模式               | 抽象工厂模式                   |
| :----------- | :--------------------------- | :------------------------- | :----------------------------- |
| **核心思想** | 用一个类根据参数创建不同产品 | **让子类决定**创建哪个产品 | 创建**一系列相关的产品族**     |
| **抽象级别** | 低（只有一个工厂类）         | 中（工厂有继承结构）       | 高（工厂和产品都有抽象）       |
| **解决问题** | 创建与使用分离               | 遵循**开闭原则**，方便扩展 | 保证**产品族**的一致性和兼容性 |
| **产品关系** | 产品之间无直接关联           | 产品之间无直接关联         | **产品之间是相关的、成套的**   |
| **遵循原则** | 违反“开闭原则”               | 遵循“开闭原则”             | 遵循“开闭原则”                 |
| **复杂度**   | 简单                         | 中等                       | 复杂                           |

+ 当你的产品数量很少，且未来`基本不会增加`时，可以使用简单工厂，代码最简洁。
+ 当你需要创建一个产品，并且希望未来可以`轻松增加更多同类型`的新产品时，使用工厂方法，扩展性最好。
+ 当你需要创建一整套相互关联、需要协同工作的产品，并确保它们风格或版本一致时，使用抽象工厂。

使用一个咖啡店的例子来详细描述三种不同，

+ 简单工厂： 一个咖啡店，你告诉店员要什么，他给你做什么。
+ 工厂方法： 连锁咖啡店，每家分店（比如美式咖啡专卖店、拿铁专卖店）只做自己招牌的那一款。
+ 抽象工厂： 套餐工厂，比如“下午茶套餐”工厂，它能生产一套（咖啡+甜点）搭配好的产品。

现在你开了一家咖啡店，你可以向工厂进货

```java
// 它知道如何创建所有类型的咖啡
class SimpleCoffeeFactory {
    public static Coffee createCoffee(String type) {
        if ("latte".equalsIgnoreCase(type)) {
            return new LatteCoffee();
        } else if ("americano".equalsIgnoreCase(type)) {
            return new AmericanoCoffee();
        } else {
            throw new IllegalArgumentException("不支持的咖啡类型: " + type);
        }
    }
}
```

当咖啡店的规模变大了，你有了对应咖啡的专门工厂

``` java
interface Coffee {
    String getName();
}
class LatteCoffee implements Coffee { /* ... */ }
class AmericanoCoffee implements Coffee { /* ... */ }


interface CoffeeFactory {
    Coffee createCoffee();
}

class LatteCoffeeFactory implements CoffeeFactory {}
class AmericanoCoffeeFactory implements CoffeeFactory {}

public class FranchiseStoreClient {
    CoffeeFactory latteFactory = new LatteCoffeeFactory();
     CoffeeFactory americanoFactory = new AmericanoCoffeeFactory();
}
```

核心在于将创建的决策权下放到了子类。客户端不再是传一个字符串参数，而是直接选择一个具体的工厂。每个工厂只负责一种产品的创建。

最后你打败了小鹿打败小星接下来准备干掉小m和小k，所以不得不拓宽产品线。

```java
interface Coffee {
    String getName();
}
interface Dessert {
    String getName();
}

// 2. 具体产品族A: 意式 (Concrete Product Family A)
class Espresso implements Coffee {
    @Override public String getName() { return "意式浓缩咖啡"; }
}
class Tiramisu implements Dessert {
    @Override public String getName() { return "提拉米苏"; }
}
// 3. 具体产品族B: 美式 (Concrete Product Family B)
class Americano implements Coffee {
    @Override public String getName() { return "美式咖啡"; }
}
class Brownie implements Dessert {
    @Override public String getName() { return "布朗尼"; }
}

/*一个生成套餐接口*/
interface DessertComboFactory {
    Coffee createCoffee();
    Dessert createDessert();
}

/*具体工厂实现意大利风情套餐*/
class ItalianComboFactory implements DessertComboFactory {
    @Override
    public Coffee createCoffee() {
        return new Espresso();
    }
    @Override
    public Dessert createDessert() {
        return new Tiramisu();
    }
}

/*具体工厂实现美国风情套餐*/
class AmericanComboFactory implements DessertComboFactory {
    @Override
    public Coffee createCoffee() {
        return new Americano();
    }
    @Override
    public Dessert createDessert() {
        return new Brownie();
    }
}

public class PremiumCafeClient {
    	/*意大利套餐*/
    DessertComboFactory italianFactory = new ItalianComboFactory();
    Coffee italianCoffee = italianFactory.createCoffee();
    Dessert italianDessert = italianFactory.createDessert();
    
    	/*美式套餐*/
    DessertComboFactory americanFactory = new AmericanComboFactory();
    Coffee americanCoffee = americanFactory.createCoffee();
    Dessert americanDessert = americanFactory.createDessert();
    
}
```

DessertComboFactory 不再是只创建一个对象，而是创建一整套（咖啡 和 甜点）。客户端选择一个具体的工厂（如ItalianComboFactory），就能保证拿到的所有产品（咖啡、甜点）都是属于同一个系列（意式）的，从而保证了兼容性。

